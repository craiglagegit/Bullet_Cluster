/*
  ------------------------------------------------------------------------------
  Author: Craig Lage, NYU CCPP
  Date: Aug 21, 2012

  Triaxial halo generation program - takes an input of DM halo data from SMILE and adds gas.

*/

#include "triaxial.h"

//***************MAIN PROGRAM***********************

int main(int argc, char *argv[])
{
  if(argc != 2)
    {
      printf("\nwrong number of arguments\n");
      printf("Only argument should be name of .cfg file");
      exit(0);
    }
  int i,io,j,seed;
  seed = (int) time(NULL);
  srand48(seed);
  struct Halo H = ReadConfig(argv[1]);  //Read configuration file and initialize parameters
  printf("alpha=%f, beta=%f, gamma=%f, G = %f, R200 = %f, Rs = %f, M200 = %f NDM = %d, Ngas = %d, NTot = %d\n",H.alpha,H.beta,H.gamma,H.G,H.R200,H.Rs,H.M200,H.NDM,H.NGas,H.NTot);
  struct Potential Pot = ReadPotentialData(H.potentialfile, &H);  //Read Potential data and create interpolation objects.
  printf("Potentialx=%f, pot=%f, f=%f\n",Pot.xa[0][1], Pot.phia[0][1],Pot.fa[0][1]);
  double xx=3.77;
  printf("x=%f, pot=%f, f=%f\n",xx, gsl_spline_eval(Pot.phi[0],xx,Pot.phiacc[0]),gsl_spline_eval(Pot.f[0],xx,Pot.facc[0]));
  printf("RhoNorm = %g, Total Mass = %g\n",H.RhoNorm, Mass(H.C,&H));
  SetRhoNorm(&H);
  printf("RhoNorm = %g, Total Mass = %g\n",H.RhoNorm, Mass(H.C,&H));
  struct UMass UM = UMLookup(&Pot, &H);  //Create lookup table for R(m) and U(R).
  double mm = 0.47, rr = H.C * 0.87;
  printf("mm = %f, Radius(m) = %f, RLookup(m) = %f, rr = %f, U(rr) = %f, ULookup(rr) = %f\n",mm,Radius(mm,&H),gsl_spline_eval(UM.rinterp,mm,UM.racc),rr,U(rr,&Pot,&H),gsl_spline_eval(UM.uinterp,rr,UM.uacc));
  fflush(stdout);
  /*
  printf("R = %f, Rho(R) = %f,AEllipse = %g\n",0.0,Rho(0.0,&H),AEllipse(0.0,&H));
  for (i = 0; i<100; i++)
  {
	xx = 5.0 / (1.0 + (double)i);
	printf("R = %f, Rho(R) = %f, Mass(R) = %f, AEllipse = %g\n",xx,Rho(xx,&H),Mass(xx,&H),AEllipse(xx,&H));
	//printf("R = %f, Rho(R) = %f\n",xx,Rho(xx,&H));
  }
  exit(0);
  */

  double R,m,x,y,z,r,theta,phi,vx,vy,vz, ufactor, alpha, beta, gamma, mtot;
  struct GadgetParticles *PTemp = (struct GadgetParticles*) calloc(H.NTot, sizeof(struct GadgetParticles));  //Particle data.
  ReadNbodyData(H.nbodyfile, PTemp, &H); // This reads in the halo data generated by SMILE
  struct GadgetParticles *P = (struct GadgetParticles*) calloc(H.NTot, sizeof(struct GadgetParticles));  //Particle data.
  struct GadgetHeader Header = CreateGadgetHeader(&H); 
  mtot = (double) H.NDM / (double) H.NDM200;
  printf("Maximum DM Particle radius is %f * R200. Total mass is %f * M200\n",H.MaxR,mtot);
  fflush(stdout);

  //ufactor = H.G * H.M200 * (1.0 - H.GF) / H.Rs;
  ufactor = H.G * H.M200 / H.Rs;
  int mcounter = 0; // Number of particles within R200
  // Now we add the gas particle data.
  for (i=0; i<H.NGas; i++) 
  {
	P[i].iParticleID = i + 1;	
	double randy = drand48();
	if (randy < 0.3) m = 0.03;
	else if (randy < 0.6) m = 0.10;
	else if (randy < 0.9) m = 0.30;
	else m = 0.5;
	//m = 1.5 * mtot * drand48(); // Larger mass ratio than DM, since gas falls off more slowly
	R = gsl_spline_eval(UM.rinterp,m,UM.racc);  // R specifies which ellipsoid we're on
	if (R < H.C)  mcounter = mcounter +1;
  	alpha = - 1.0;
  	beta =  - gsl_pow_2(Qphi(R,&H)); // These are the shape parameters of the potential ellipsoids 
  	gamma = - gsl_pow_2(Pphi(R,&H)); // These are the shape parameters of the potential ellipsoids 
	RandomDirection(R,&theta,&phi,&x,&y,&z,alpha,beta,gamma,&H); // Choose a random (theta, phi)
	double Rcheck = -(x*x/alpha + y*y/beta + z*z/gamma);
	if (i%100000 == 0)
	  {
	    printf("m = %f, R = %f, alpha = %f, beta = %f, gamma = %f, Halpha = %f, Hbeta = %f, Hgamma = %f\n",m, R, alpha, beta, gamma,H.alpha,H.beta,H.gamma);
	    printf("m = %f, R = %f, Rcheck = %f,x = %f, y = %f, z = %f\n",m, R,Rcheck, x,y,z);
	  }

	r = sqrt(gsl_pow_2(x) + gsl_pow_2(y) + gsl_pow_2(z));
	P[i].rOriginDistance = H.Rs * r; 
	P[i].rAxisDistance = H.Rs * sqrt(gsl_pow_2(x) + gsl_pow_2(y));
	P[i].rLongitude = theta;
	P[i].rLatitude = phi;
	P[i].rPosition[0] = H.Rs * x;
	P[i].rPosition[1] = H.Rs * y;
	P[i].rPosition[2] = H.Rs * z;
	P[i].rVelocity[0] = 0.0;
	P[i].rVelocity[1] = 0.0;
	P[i].rVelocity[2] = 0.0;
	P[i].iParticleType = 0;
	P[i].rU = gsl_spline_eval(UM.uinterp,R,UM.uacc) * ufactor;// This needs to be checked
	P[i].rRho = Rho(R,&H);// Is this right?
	P[i].rNe = 0.0;
	if (i % 100000 == 0)   printf("Particle %d, ID = %d, x = %f, y = %f, z = %f, vx = %f, vy = %f, vz = %f, u = %f, mass = %f\n",i,P[i].iParticleID,P[i].rPosition[0],P[i].rPosition[1],P[i].rPosition[2],P[i].rVelocity[0],P[i].rVelocity[1],P[i].rVelocity[2],P[i].rU,P[i].rMass);
	fflush(stdout);
  }
  // Now set the gas particle mass, based on the number of particles within R200
  double gmass = (H.M200 * H.GF) / (double) mcounter;
  for (i=0; i<H.NGas; i++) 
  {
    P[i].rMass = gmass;
  }
  printf("A total of %d gas particles were within R200.\n",mcounter);
  // Next we transfer the DM data from PTemp to P
  for (i=H.NGas; i<H.NTot; i++) 
  {
	io = i - H.NGas;
	P[i].iParticleID = i+1;	
	P[i].iParticleType = 1;	
	P[i].rMass = PTemp[io].rMass;
			for (j=0; j<3; j++)
			{
				P[i].rPosition[j] = PTemp[io].rPosition[j];
				P[i].rVelocity[j] = PTemp[io].rVelocity[j];
			}
	if (i % 100000 == 0)   printf("Particle %d, ID = %d, x = %f, y = %f, z = %f, vx = %f, vy = %f, vz = %f, u = %f, mass = %f\n",i,P[i].iParticleID,P[i].rPosition[0],P[i].rPosition[1],P[i].rPosition[2],P[i].rVelocity[0],P[i].rVelocity[1],P[i].rVelocity[2],P[i].rU,P[i].rMass);
	fflush(stdout);
	
  }  
  //CleanUp(P,&H);
  WriteProfiles(H.profile, &H, &UM, &Pot);  
  WriteGadgetFile(H.outfile, Header, P);
  //CharacterizeDistribution(P,G,&H);*/

  free(P);
  free(PTemp);

  return 0;
}
//***************END MAIN PROGRAM***********************
